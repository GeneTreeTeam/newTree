/**
 * Mark as style data
 * @function asStyleData
 * @param {string} scopeSelector - Selector which wraps data
 * @param {Object} data - Style data
 * @returns {Object} Style data
 */
'use strict';

import _toConsumableArray from "@babel/runtime/helpers/toConsumableArray";
import _typeof from "@babel/runtime/helpers/typeof";
import _defineProperty from "@babel/runtime/helpers/defineProperty";
import argx from 'argx';

var combineSelectors = function combineSelectors() {
  for (var _len = arguments.length, selectors = new Array(_len), _key = 0; _key < _len; _key++) {
    selectors[_key] = arguments[_key];
  }

  return selectors.filter(Boolean).map(function (selector) {
    return String(selector).trim();
  }).reduce(function (combined, selector) {
    if (!combined) {
      return selector;
    }

    var JOIN_PATTERN = /^&/;

    if (JOIN_PATTERN.test(selector)) {
      return combined + selector.replace(JOIN_PATTERN, '');
    }

    return [combined, selector].join(' ');
  }, null).trim();
};

var selectorData = function selectorData(selector, data) {
  var attributes = {};
  var nested = {};

  var _arr = Object.keys(data);

  for (var _i = 0; _i < _arr.length; _i++) {
    var key = _arr[_i];

    switch (_typeof(data[key])) {
      case 'object':
        {
          nested[key] = data[key];
          break;
        }

      default:
        {
          attributes[key] = data[key];
          break;
        }
    }
  }

  return Object.assign(_defineProperty({}, selector, attributes), asStyleData(selector, nested));
};
/** @lends asStyleData */


function asStyleData(scopeSelector, data) {
  var args = argx(arguments);
  scopeSelector = args.shift('string');
  data = args.pop('object');
  return Object.keys(data).reduce(function (scoped, selector) {
    return Object.assign.apply(Object, [scoped].concat(_toConsumableArray(selector.split(',').map(function (aSelector) {
      var created = selectorData(combineSelectors(scopeSelector, aSelector), data[selector]);
      return Object.keys(created).reduce(function (result, key) {
        return Object.assign(result, _defineProperty({}, key, Object.assign({}, scoped[key] || {}, created[key])));
      }, {});
    }))));
  }, {});
}

export default asStyleData;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzU3R5bGVEYXRhLmpzIl0sIm5hbWVzIjpbImFyZ3giLCJjb21iaW5lU2VsZWN0b3JzIiwic2VsZWN0b3JzIiwiZmlsdGVyIiwiQm9vbGVhbiIsIm1hcCIsInNlbGVjdG9yIiwiU3RyaW5nIiwidHJpbSIsInJlZHVjZSIsImNvbWJpbmVkIiwiSk9JTl9QQVRURVJOIiwidGVzdCIsInJlcGxhY2UiLCJqb2luIiwic2VsZWN0b3JEYXRhIiwiZGF0YSIsImF0dHJpYnV0ZXMiLCJuZXN0ZWQiLCJPYmplY3QiLCJrZXlzIiwia2V5IiwiYXNzaWduIiwiYXNTdHlsZURhdGEiLCJzY29wZVNlbGVjdG9yIiwiYXJncyIsImFyZ3VtZW50cyIsInNoaWZ0IiwicG9wIiwic2NvcGVkIiwic3BsaXQiLCJhU2VsZWN0b3IiLCJjcmVhdGVkIiwicmVzdWx0Il0sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7OztBQU9BOzs7OztBQUNBLE9BQU9BLElBQVAsTUFBaUIsTUFBakI7O0FBRUEsSUFBTUMsZ0JBQWdCLEdBQUcsU0FBbkJBLGdCQUFtQjtBQUFBLG9DQUFJQyxTQUFKO0FBQUlBLElBQUFBLFNBQUo7QUFBQTs7QUFBQSxTQUFrQkEsU0FBUyxDQUNqREMsTUFEd0MsQ0FDakNDLE9BRGlDLEVBRXhDQyxHQUZ3QyxDQUVwQyxVQUFDQyxRQUFEO0FBQUEsV0FBY0MsTUFBTSxDQUFDRCxRQUFELENBQU4sQ0FBaUJFLElBQWpCLEVBQWQ7QUFBQSxHQUZvQyxFQUd4Q0MsTUFId0MsQ0FHakMsVUFBQ0MsUUFBRCxFQUFXSixRQUFYLEVBQXdCO0FBQzlCLFFBQUksQ0FBQ0ksUUFBTCxFQUFlO0FBQ2IsYUFBT0osUUFBUDtBQUNEOztBQUNELFFBQU1LLFlBQVksR0FBRyxJQUFyQjs7QUFDQSxRQUFJQSxZQUFZLENBQUNDLElBQWIsQ0FBa0JOLFFBQWxCLENBQUosRUFBaUM7QUFDL0IsYUFBT0ksUUFBUSxHQUFHSixRQUFRLENBQUNPLE9BQVQsQ0FBaUJGLFlBQWpCLEVBQStCLEVBQS9CLENBQWxCO0FBQ0Q7O0FBQ0QsV0FBTyxDQUFDRCxRQUFELEVBQVdKLFFBQVgsRUFBcUJRLElBQXJCLENBQTBCLEdBQTFCLENBQVA7QUFDRCxHQVp3QyxFQVl0QyxJQVpzQyxFQWF4Q04sSUFid0MsRUFBbEI7QUFBQSxDQUF6Qjs7QUFlQSxJQUFNTyxZQUFZLEdBQUcsU0FBZkEsWUFBZSxDQUFDVCxRQUFELEVBQVdVLElBQVgsRUFBb0I7QUFDdkMsTUFBTUMsVUFBVSxHQUFHLEVBQW5CO0FBQ0EsTUFBTUMsTUFBTSxHQUFHLEVBQWY7O0FBRnVDLGFBR3JCQyxNQUFNLENBQUNDLElBQVAsQ0FBWUosSUFBWixDQUhxQjs7QUFHdkMsMkNBQXFDO0FBQWhDLFFBQU1LLEdBQUcsV0FBVDs7QUFDSCxvQkFBZUwsSUFBSSxDQUFDSyxHQUFELENBQW5CO0FBQ0UsV0FBSyxRQUFMO0FBQWU7QUFDYkgsVUFBQUEsTUFBTSxDQUFDRyxHQUFELENBQU4sR0FBY0wsSUFBSSxDQUFDSyxHQUFELENBQWxCO0FBQ0E7QUFDRDs7QUFDRDtBQUFTO0FBQ1BKLFVBQUFBLFVBQVUsQ0FBQ0ksR0FBRCxDQUFWLEdBQWtCTCxJQUFJLENBQUNLLEdBQUQsQ0FBdEI7QUFDQTtBQUNEO0FBUkg7QUFVRDs7QUFDRCxTQUFPRixNQUFNLENBQUNHLE1BQVAscUJBQ0poQixRQURJLEVBQ09XLFVBRFAsR0FFSk0sV0FBVyxDQUFDakIsUUFBRCxFQUFXWSxNQUFYLENBRlAsQ0FBUDtBQUdELENBbEJEO0FBb0JBOzs7QUFDQSxTQUFTSyxXQUFULENBQXNCQyxhQUF0QixFQUFxQ1IsSUFBckMsRUFBMkM7QUFDekMsTUFBTVMsSUFBSSxHQUFHekIsSUFBSSxDQUFDMEIsU0FBRCxDQUFqQjtBQUNBRixFQUFBQSxhQUFhLEdBQUdDLElBQUksQ0FBQ0UsS0FBTCxDQUFXLFFBQVgsQ0FBaEI7QUFDQVgsRUFBQUEsSUFBSSxHQUFHUyxJQUFJLENBQUNHLEdBQUwsQ0FBUyxRQUFULENBQVA7QUFDQSxTQUFPVCxNQUFNLENBQUNDLElBQVAsQ0FBWUosSUFBWixFQUNKUCxNQURJLENBQ0csVUFBQ29CLE1BQUQsRUFBU3ZCLFFBQVQsRUFBc0I7QUFDNUIsV0FBT2EsTUFBTSxDQUFDRyxNQUFQLE9BQUFILE1BQU0sR0FBUVUsTUFBUiw0QkFDUnZCLFFBQVEsQ0FBQ3dCLEtBQVQsQ0FBZSxHQUFmLEVBQW9CekIsR0FBcEIsQ0FBd0IsVUFBQzBCLFNBQUQsRUFBZTtBQUN4QyxVQUFNQyxPQUFPLEdBQUdqQixZQUFZLENBQzFCZCxnQkFBZ0IsQ0FBQ3VCLGFBQUQsRUFBZ0JPLFNBQWhCLENBRFUsRUFFMUJmLElBQUksQ0FBQ1YsUUFBRCxDQUZzQixDQUE1QjtBQUlBLGFBQU9hLE1BQU0sQ0FBQ0MsSUFBUCxDQUFZWSxPQUFaLEVBQXFCdkIsTUFBckIsQ0FBNEIsVUFBQ3dCLE1BQUQsRUFBU1osR0FBVDtBQUFBLGVBQWlCRixNQUFNLENBQUNHLE1BQVAsQ0FBY1csTUFBZCxzQkFDakRaLEdBRGlELEVBQzNDRixNQUFNLENBQUNHLE1BQVAsQ0FBYyxFQUFkLEVBQWtCTyxNQUFNLENBQUNSLEdBQUQsQ0FBTixJQUFlLEVBQWpDLEVBQXFDVyxPQUFPLENBQUNYLEdBQUQsQ0FBNUMsQ0FEMkMsRUFBakI7QUFBQSxPQUE1QixFQUVILEVBRkcsQ0FBUDtBQUdELEtBUkUsQ0FEUSxHQUFiO0FBV0QsR0FiSSxFQWFGLEVBYkUsQ0FBUDtBQWNEOztBQUVELGVBQWVFLFdBQWYiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBNYXJrIGFzIHN0eWxlIGRhdGFcbiAqIEBmdW5jdGlvbiBhc1N0eWxlRGF0YVxuICogQHBhcmFtIHtzdHJpbmd9IHNjb3BlU2VsZWN0b3IgLSBTZWxlY3RvciB3aGljaCB3cmFwcyBkYXRhXG4gKiBAcGFyYW0ge09iamVjdH0gZGF0YSAtIFN0eWxlIGRhdGFcbiAqIEByZXR1cm5zIHtPYmplY3R9IFN0eWxlIGRhdGFcbiAqL1xuJ3VzZSBzdHJpY3QnXG5pbXBvcnQgYXJneCBmcm9tICdhcmd4J1xuXG5jb25zdCBjb21iaW5lU2VsZWN0b3JzID0gKC4uLnNlbGVjdG9ycykgPT4gc2VsZWN0b3JzXG4gIC5maWx0ZXIoQm9vbGVhbilcbiAgLm1hcCgoc2VsZWN0b3IpID0+IFN0cmluZyhzZWxlY3RvcikudHJpbSgpKVxuICAucmVkdWNlKChjb21iaW5lZCwgc2VsZWN0b3IpID0+IHtcbiAgICBpZiAoIWNvbWJpbmVkKSB7XG4gICAgICByZXR1cm4gc2VsZWN0b3JcbiAgICB9XG4gICAgY29uc3QgSk9JTl9QQVRURVJOID0gL14mL1xuICAgIGlmIChKT0lOX1BBVFRFUk4udGVzdChzZWxlY3RvcikpIHtcbiAgICAgIHJldHVybiBjb21iaW5lZCArIHNlbGVjdG9yLnJlcGxhY2UoSk9JTl9QQVRURVJOLCAnJylcbiAgICB9XG4gICAgcmV0dXJuIFtjb21iaW5lZCwgc2VsZWN0b3JdLmpvaW4oJyAnKVxuICB9LCBudWxsKVxuICAudHJpbSgpXG5cbmNvbnN0IHNlbGVjdG9yRGF0YSA9IChzZWxlY3RvciwgZGF0YSkgPT4ge1xuICBjb25zdCBhdHRyaWJ1dGVzID0ge31cbiAgY29uc3QgbmVzdGVkID0ge31cbiAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMoZGF0YSkpIHtcbiAgICBzd2l0Y2ggKHR5cGVvZiBkYXRhW2tleV0pIHtcbiAgICAgIGNhc2UgJ29iamVjdCc6IHtcbiAgICAgICAgbmVzdGVkW2tleV0gPSBkYXRhW2tleV1cbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgYXR0cmlidXRlc1trZXldID0gZGF0YVtrZXldXG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBPYmplY3QuYXNzaWduKHtcbiAgICBbc2VsZWN0b3JdOiBhdHRyaWJ1dGVzLFxuICB9LCBhc1N0eWxlRGF0YShzZWxlY3RvciwgbmVzdGVkKSlcbn1cblxuLyoqIEBsZW5kcyBhc1N0eWxlRGF0YSAqL1xuZnVuY3Rpb24gYXNTdHlsZURhdGEgKHNjb3BlU2VsZWN0b3IsIGRhdGEpIHtcbiAgY29uc3QgYXJncyA9IGFyZ3goYXJndW1lbnRzKVxuICBzY29wZVNlbGVjdG9yID0gYXJncy5zaGlmdCgnc3RyaW5nJylcbiAgZGF0YSA9IGFyZ3MucG9wKCdvYmplY3QnKVxuICByZXR1cm4gT2JqZWN0LmtleXMoZGF0YSlcbiAgICAucmVkdWNlKChzY29wZWQsIHNlbGVjdG9yKSA9PiB7XG4gICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihzY29wZWQsXG4gICAgICAgIC4uLnNlbGVjdG9yLnNwbGl0KCcsJykubWFwKChhU2VsZWN0b3IpID0+IHtcbiAgICAgICAgICBjb25zdCBjcmVhdGVkID0gc2VsZWN0b3JEYXRhKFxuICAgICAgICAgICAgY29tYmluZVNlbGVjdG9ycyhzY29wZVNlbGVjdG9yLCBhU2VsZWN0b3IpLFxuICAgICAgICAgICAgZGF0YVtzZWxlY3Rvcl1cbiAgICAgICAgICApXG4gICAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKGNyZWF0ZWQpLnJlZHVjZSgocmVzdWx0LCBrZXkpID0+IE9iamVjdC5hc3NpZ24ocmVzdWx0LCB7XG4gICAgICAgICAgICBba2V5XTogT2JqZWN0LmFzc2lnbih7fSwgc2NvcGVkW2tleV0gfHwge30sIGNyZWF0ZWRba2V5XSksXG4gICAgICAgICAgfSksIHt9KVxuICAgICAgICB9KVxuICAgICAgKVxuICAgIH0sIHt9KVxufVxuXG5leHBvcnQgZGVmYXVsdCBhc1N0eWxlRGF0YVxuIl19